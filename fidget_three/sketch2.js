
import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import * as p5 from 'p5';
import * as mt from 'mt';


let container, stats;

let camera, scene, renderer;

let group;

let targetRotation = 0;
let targetRotationOnPointerDown = 0;

let pointerX = 0;
let pointerXOnPointerDown = 0;

let windowHalfX = window.innerWidth / 2;

let anim_pos = 0;
let anim_rot = 0;

let uniforms;

/////////////////////////////////// OLD
/* prevents the mobile browser from processing some default
 * touch events, like swiping left for "back" or scrolling
 * the page.
 */
document.ontouchmove = function(event) {
    event.preventDefault();
  };

// Disable pull-to-refresh using JavaScript
document.body.addEventListener('touchmove', function(event) {
event.preventDefault();
}, { passive: false });

var mouseConstraint = mt.Matter.MouseConstraint.create(mt.engine, {
//mouse: mouse,
collisionFilter: {category: utils.collision_category.mouse, mask: utils.collision_category.inter}, // <---
constraint: {
    // allow bodies on mouse to rotate
    angularStiffness: 0,
    render: {
        visible: false
    }
}
});
mt.Matter.Composite.add(mt.engine.world, mouseConstraint);

var width       = 400
var height      = 400
var ground_enable = false
var Fs_sequence = null

var nbr = 10
var debug = false

var use_webgl = false
var shaders_nbr = 0

var shdrs = [] 

var do_shdr_test = false
var shdr_test = null

var end_update_count = 0
var draw_count = 0;
/////////////////////////////////// OLD
  



init();

function init() {


    container = document.createElement( 'div' );
    document.body.appendChild( container );

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xf0f0f0 );

    let width = window.innerWidth;
    let height = window.innerHeight;
    camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
    camera.position.set( 0, 0, 500 );
    scene.add( camera );

    const light = new THREE.PointLight( 0xffffff, 2.5, 0, 0 );
    camera.add( light );

    group = new THREE.Group();
    group.position.y = 50;
    scene.add( group );

    const loader = new THREE.TextureLoader();
    const texture = loader.load( 'textures/uv_grid_opengl.jpg' );
    texture.colorSpace = THREE.SRGBColorSpace;

    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set( 0.008, 0.008 );

    function addShape( shape, x, y, z, rx, ry, rz, s ) {

        // flat shape with texture
        // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

        let geometry = new THREE.ShapeGeometry( shape );

        let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );
        mesh.position.set( x, y, z );
        mesh.rotation.set( rx, ry, rz );
        mesh.scale.set( s, s, s );
        group.add( mesh );
    }

    // Square


    // Rounded rectangle

    const roundedRectShape = new THREE.Shape();

    ( function roundedRect( ctx, x, y, width, height, radius ) {

        let w = width/2.0;
        let h = height/2.0;
        
        ctx.moveTo( x-w, y-h + radius );
        ctx.lineTo( x-w, y-h + height - radius );
        ctx.quadraticCurveTo( x-w, y-h + height, x-w + radius, y-h + height );
        ctx.lineTo( x-w + width - radius, y-h + height );
        ctx.quadraticCurveTo( x-w + width, y-h + height, x-w + width, y-h + height - radius );
        ctx.lineTo( x-w + width, y-h + radius );
        ctx.quadraticCurveTo( x-w + width, y-h, x-w + width - radius, y-h );
        ctx.lineTo( x-w + radius, y-h );
        ctx.quadraticCurveTo( x-w, y-h, x-w, y-h + radius );

    } )( roundedRectShape, 0, 0, 75, 25, 3 );

    // Circle

    const circleRadius = 20;
    const circleShape = new THREE.Shape()
        .moveTo( 0, circleRadius )
        .quadraticCurveTo( circleRadius, circleRadius, circleRadius, 0 )
        .quadraticCurveTo( circleRadius, - circleRadius, 0, - circleRadius )
        .quadraticCurveTo( - circleRadius, - circleRadius, - circleRadius, 0 )
        .quadraticCurveTo( - circleRadius, circleRadius, 0, circleRadius );


    addShape( roundedRectShape, -75, 0, 0, 0, 0, 0, 1 );
    addShape( roundedRectShape, 75, 0, 0, 0, 0, 0, 1 );
    addShape( roundedRectShape, 0, 75, 0, 0, 0, 3.14/2., 1 );
    addShape( roundedRectShape, 0, -75, 0, 0, 0, 3.14/2., 1 );

    addShape( roundedRectShape, 75, 75, 0, 0, 0, -3.14/4., 1 );	
    addShape( roundedRectShape, -75, -75, 0, 0, 0, -3.14/4., 1 );		
    addShape( roundedRectShape, 75, -75, 0, 0, 0, 3.14/4., 1 );	
    addShape( roundedRectShape, -75, 75, 0, 0, 0, 3.14/4., 1 );	
    addShape( circleShape, 0, 0, 0, 0, 0, 0, 1 );
    
    
    ///////////////// Background shader
    uniforms = {
        time: { value: 1.0 }
    };

    const geometry = new THREE.PlaneGeometry( 2, 2 );
    uniforms = {
        time: { value: 1.0 }
    };

    const material = new THREE.ShaderMaterial( {

        uniforms: uniforms,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent

    } );

    const mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh );	
    
    /////////////////


    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setAnimationLoop( animate );
    container.appendChild( renderer.domElement );

    stats = new Stats();
    container.appendChild( stats.dom );

    container.style.touchAction = 'none';
    container.addEventListener( 'pointerdown', onPointerDown );

    //

    window.addEventListener( 'resize', onWindowResize );

    /////////////////////////////////// OLD
    console.log('setup : sketch')
    p5.createCanvas(width, height);
    mt.Matter.Composite.add(mt.engine.world, create_boundary_wall_collision(width,height,ground_enable));
  
    var runner = mt.Matter.Runner.create();
    mt.Matter.Runner.run(runner, mt.engine);
    
    mt.engine.gravity.scale = 0.0
    
    let m = new Matrix()
    m.setTranslation(width/2, height/2 )
    
    let s = 2.2
    F_sequence = new fidgets_sequence(nbr,m,s,shdrs,debug)
    F_sequence.setup()
    /////////////////////////////////// OLD
}

function onWindowResize() {

    windowHalfX = window.innerWidth / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

//

function onPointerDown( event ) {

    if ( event.isPrimary === false ) return;

    pointerXOnPointerDown = event.clientX - windowHalfX;
    targetRotationOnPointerDown = targetRotation;

    document.addEventListener( 'pointermove', onPointerMove );
    document.addEventListener( 'pointerup', onPointerUp );

}

function onPointerMove( event ) {

    if ( event.isPrimary === false ) return;

    pointerX = event.clientX - windowHalfX;

    targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

}

function onPointerUp() {

    if ( event.isPrimary === false ) return;

    document.removeEventListener( 'pointermove', onPointerMove );
    document.removeEventListener( 'pointerup', onPointerUp );

}

//

function animate() {
    anim_pos += 1;

    group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
    group.children[0].position.x = Math.sin(anim_pos* 0.05)*75-140.
    group.children[1].position.x = Math.sin(anim_pos* 0.05+3.14)*75+140.
    group.children[2].position.y = Math.sin(anim_pos* 0.05)*75-140.
    group.children[3].position.y = Math.sin(anim_pos* 0.05+3.14)*75+140.

    group.children[4].rotation.z = anim_pos* 0.05
    group.children[5].rotation.z = anim_pos* 0.05
    group.children[6].rotation.z = anim_pos* 0.05
    group.children[7].rotation.z = anim_pos* 0.05


    uniforms[ 'time' ].value = performance.now() / 1000;

    renderer.render( scene, camera );


    stats.update();

    /////////////////////////////////////////// old
    F_sequence.update()
    F_sequence.draw()
    draw_count += 1
    /////////////////////////////////////////// old

}

